import { Octokit } from "octokit";

/**
 * createPrForWorkflow - create a branch, add/update workflow file, and open a PR
 * @param {Octokit} octokit - authenticated Octokit instance (MUST be installation-scoped from app.auth(installationId))
 * @param {string} owner
 * @param {string} repo
 * @param {string} filePath - path in repo (e.g. .github/workflows/ci.yml)
 * @param {string} content - raw file content (string)
 * @param {string} branchName - optional branch name (auto-generated if omitted)
 */
export async function createPrForWorkflow(octokit, owner, repo, filePath, content, branchName) {
  if (!octokit) throw new Error("Octokit client required");

  // Debug: ensure this octokit is the installation-scoped client
  console.log("üîê Auth type (should be installation token):", octokit?.auth);

  // Get repository info to determine default branch
  const { data: repoInfo } = await octokit.request("GET /repos/{owner}/{repo}", { owner, repo });
  const defaultBranch = repoInfo.default_branch || "main";

  // Get sha of default branch
  const ref = `heads/${defaultBranch}`;
  const { data: refData } = await octokit.request("GET /repos/{owner}/{repo}/git/ref/{ref}", {
    owner,
    repo,
    ref,
  });
  const baseSha = refData.object.sha;

  // Prepare branch name
  const time = new Date().toISOString().replace(/[:.]/g, "-");
  const br = branchName || `pipeline-gen/ci-${time}`;

  // Create branch (ref)
  try {
    await octokit.request("POST /repos/{owner}/{repo}/git/refs", {
      owner,
      repo,
      ref: `refs/heads/${br}`,
      sha: baseSha,
    });
  } catch (err) {
    if (err.status === 422) {
      // branch already exists ‚Äî continue
    } else {
      throw err;
    }
  }

  // Create or update file on the new branch (use PUT /repos/{owner}/{repo}/contents/{path})
  const contentBase64 = Buffer.from(content, "utf8").toString("base64");

  // Check if file exists to include SHA (required for updates)
  let sha = undefined;
  try {
    const existing = await octokit.request(
      "GET /repos/{owner}/{repo}/contents/{path}",
      { owner, repo, path: filePath, ref: br }
    );
    sha = existing.data.sha;
    console.log(`üìù File exists on branch ${br}, SHA: ${sha}`);
  } catch (err) {
    if (err.status !== 404) throw err;
    console.log(`‚ú® File does not exist yet on branch ${br}, creating new`);
  }

  await octokit.request("PUT /repos/{owner}/{repo}/contents/{path}", {
    owner,
    repo,
    path: filePath,
    message: "chore(ci): add generated CI workflow (pipeline-gen)",
    content: contentBase64,
    branch: br,
    sha, // only included if file exists (required for updates, omitted for creates)
  });

  // Create a pull request
  const prTitle = "[pipeline-gen] Proposed CI workflow";
  const prBody = "This PR was generated by pipeline-gen GitHub App. Please review and adjust as needed.";

  try {
    // Check if PR already exists for this branch
    const { data: existingPrs } = await octokit.request("GET /repos/{owner}/{repo}/pulls", {
      owner,
      repo,
      state: "open",
      head: `${owner}:${br}`,
    });
    
    if (existingPrs.length > 0) {
      console.log(`‚ÑπÔ∏è PR already exists for branch ${br}: ${existingPrs[0].html_url}`);
      return existingPrs[0];
    }
  } catch (err) {
    console.warn("‚ö†Ô∏è Could not check for existing PRs:", err?.message);
  }

  const { data: pr } = await octokit.request("POST /repos/{owner}/{repo}/pulls", {
    owner,
    repo,
    title: prTitle,
    head: br,
    base: defaultBranch,
    body: prBody,
  });

  return pr;
}
